---
title: "PROGRAMMING RUST"
date: 2018-02-05 06:29:03
---

機械学習系の小難しい本ばかり読んでると疲れるので、息抜きになんか新しいプログラミング言語の本でも読むか、と買った、rustの本。

<iframe style="width:120px;height:240px;" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" src="https://rcm-fe.amazon-adsystem.com/e/cm?ref=qf_sp_asin_til&t=karino203-22&m=amazon&o=9&p=8&l=as1&IS1=1&detail=1&asins=B077NSY211&bc1=ffffff&lt1=_top&fc1=333333&lc1=0066c0&bg1=ffffff&f=ifr"> </iframe>

別段使う気も無く、単なる教養として読む気です。

### 2章まで

単語が分からない。  
admonish 勧告する

最初の方の例のunwrapというものがなんなのか、説明読んでも良く分からなかった。
とりあえず先に進むと分かるようになるのを期待。

Result型とかを見てると、代数的データ型なのかね。

マンデルブロの例はコード以外の説明が長くてゲンナリする。なんで開幕にこの例を持ってきてしまうのか…

chunks_mutとかは、お、なんか下ではいろいろありそうだな、という気がする。
スレッド同士の協調作業が無い例だといまいち実力の程は分からないが、それは以後に期待か。

### rustってどこに使うのだろう？

使う気は無いとはいえ、そういうモチベーションの所は気になる。

言語的には軽く使える関数型言語っぽいスクリプト、という印象だが、これ、どこに使うのだろうか？

メモリの制約とか気にしてる！とか言っててCとかC++が良く言及されてるので、Cの代わりに使うのか？

Cというとメモリのディスクリプタをセットアップしてない状態でバイナリ操作してPCIeのパラメータを変更したりSPIとかの少し込み入ったプロトコルを持つデバイスを叩くのに使うよな。

そういう用途なのなしら？

とりあえずランタイム無しで動かすとどうなるんだろう？と少しググるとこんなのが。

[zero.rs](https://github.com/pcwalton/zero.rs/blob/master/zero.rs)

ふむ、memcpy, memmove, abortくらいはアセンブリで書いてやるが、mallocとfreeは辛いなぁ。
というかなんでコード領域じゃない文字列要るんだ？

なんかあんまりC言語の代わりに使える感じはしない。
ただmalloc相当の物を用意するくらいは出来る環境もあるだろう。
へんてこなデバイス上のクロス開発、みたいなパターンだと、用意しなきゃいけないランタイムが小さいのは良さそう。

ブラウザ書く為に出来た言語なので、ブラウザ書く、というのはまぁいい。
でもデスクトップアプリなんてイマドキほとんど書かないだろう。

並列性が生きる用途ってなんだろう？
例えばMapReduceとかで使うなら言語が並列で動いてもあんまいい事無い。

webサーバーの中で動くスクリプトもそうだよなぁ。

この手の奴とか、コマンドラインのちょっとしたツールくらいなら、
golangくらいのいい加減で面倒が無い言語の方が良い気はする。

RDBのエンジンとかインデクサとかLightGBMとかそういうの作る時には良いかもなぁ。
その辺作る時にこんな感じに書けると良さそうね。

ただそういうのってちょろっと試す用途には向かないよね。ちょろっとRDBMS書くか！とか無理。

サーバーサイドでしか使わない用途じゃないとKotlinで書き直すハメになって辛そうというのも悩ましいな。

何書く時に使うのかなぁ。

### 三章、基本の型

数値のリテラルにアンダーバーが入れられる、ってこれどっかの言語でも見た記憶があるが、流行ってるのか？使った事無いんだが…

floating pointのあたりで飽きてくる。
開幕これって読む人的には結構辛い。
まぁバンバン飛ばせばいいんだろうけれど。

tuppleのインデクシングは即値じゃないと駄目！まじか！
コンパイル時にオフセット決めるのか。

配列とかvectorくらいまで来るとダルさも減ってくるな。
それにしてもcollectは戻りの変数に型が要るって、return valueでもmethod overload出来るのかな。
collect_vecでは何故駄目なのか…という気もするが。

functional languageの定義には笑ってしまった。

stringで内部のエンコーディングの話とかスタック上のリファレンスの中身とかの話が出てくるのはいいね。
rustなんて言語に興味持つならCやC++は当然分かるでしょ？という事だな。

string literalとStringが違うのはいいんだけど、なんか違う名前つけておいて欲しかったなぁ。lstringとか。

----

3章読み終わり。
intとかfloatはさすがにだるかったが、後半のメモリレイアウトから面白くなってくるね。
referenceが必ず長さも持つ、というのは面白い。
厳密には無駄な場合もあるけど、だいたい長さも持つ方がいいよね、というのは昔ガラケー会社でブラウザ書いてた時にもライブラリで一貫して採用してて、結構メモリ制約がきつい所でも頑張ってたのでまぁまぁ同意する所。

本としては、この構成はどうなのかなぁ。
一番挫折しやすい序盤にこのかったるい章を持ってきてしまうのはどうなのか。  
ま、この位なら頑張って乗り越えるけどね。

あとC++プログラマを前提としている気がする。そこまで最新の機能とかは知らなくてもいいだろうけど、スタック上にどうオブジェクトが置かれるか、くらいは知ってる事が前提に思う。

----

### 4章、Ownership

冒頭から煽ってくるね！(・∀・)ｲｲﾈ!!  
そうそう、こういうのが読みたかったんだよ。

Moveのあたりを読んでるが、面白いね。
こういうのはやっぱ詳しい人が書かないとね。
この本書いてる奴は相当の実力者だよな。  
と、末尾を見てみると著者の片方のJim Blandyというのは凄い経歴だな。おっさんたるものこうありたいね。

unwrapってあれか。Result型とかから中取り出すのか。

std::mem::replaceはなかなか大仰だなぁ。
これは意図的にそうしているのだろうなぁ。

うぉ！コピーかどうかはattributeで指定なのか！rustはattribute、処理系自身も使うのね。

----

久しぶりに続きから読もうとしたら忘れてる^^;  
という事で軽く最初からパラパラめくってだいたい思い出す。

### チックA、ライフタイムパラメータ

staticに代入する場合、ライフタイムパラメータをあらわに書く必要がある。
なるほど、これでsignitureからライフタイムが判断出来るのか。

なかなか面白くなってきたね！これがRustかー。

### 5章読み終わった雑感

リファレンスのborrow周辺はだいたい読み終わった事になると思う。
なかなか面白いが、これがどのくらいrestiictiveなのかは実際に書いてみないと分からないねぇ。
書いてみないとこのアイデアの良し悪しも評価出来んなぁ。  
ま、今回は教養として読んでるだけなので、是非を評価出来るほどの理解まで至らなくてもそういうものだろう。

ただ、ぱっと聞いた感じは良さそうな気がする。
本書でも語られているが、結局C++でコード書く時も似たような事は頭の中では考えていた訳で。
それがJavaとかと比較して良いかは良く分からないが、C++の代わりとしては良い気がする。

本としては、この辺まで読むとだいぶ面白くなってくるね。3章までのつまらなさは異常。

### 7章のError周りまで読み終わり

4, 5章はオーナーシップとかリファレンスで面白かったが、6章は式とか優先順位で凡庸な内容でつまらない。
7章も「?」とかunwarpとか良く考えられてるな、とは思うが、割と単純な仕組みなのでそんな驚きは無い。

結局使う気はなく教養として学んでる時は、他の言語にもある機能はどうでも良いのだよなぁ。

本としてはしっかりと書かれていて分からない所は無いので、分かりやすく書かれた良い本だと思う。
ただちょっと退屈ね。

# 8章 crates and modules

もうyet anotherなパッケージシステムはうんざり…という気分になる章だけど、binがライブラリと一緒における、とか、テストが内部に埋め込めるとか、
こういうのはなかなか便利そうでいいね。

### 8章読み終わり

何も驚きや感動は無いが、良い意味で普通だ。C++とは雲泥の差があるね。
ライブラリ周辺はやはりこういう風に最初の所で決めてくれないと辛いよなぁ。

レガシー的な理由が無くrustくらいのレイヤーの言語で開発しなきゃいけない時はrustを選びたくなった。
そんなシチュエーションがあるかは未だに良く分からないが。

### 9章のstructはさらっと読む

最後のRefCell以外は驚きもなくさらっと読み終わる。
この辺素直で変な事無いのは良い所ね。

そろそろ本の最初の方忘れてきたので、気合い入れて一気に読んでしまうかなぁ。

### 10章 Enumとpattern match

今となっては普通の、enumとpattern matchの話。
システムプログラムでこれが使えるのは嬉しいね。

アンパサンドつける所とか全部は理解出来てないが、この辺はどうせすぐ忘れるから使う時まではあんま神経質にならずに進む。

お、if letもあるんだ。いいね！

### 11章 traitsとgenerics

traitsにはDynamic Cast相当の物が無い、と聞いて、へー、と思う。

genericsはwhere書けるんだね。csharpみたいだ。

traitの文法はインターフェースを継承するよりも分かりやすい気がする。こっちの方がいいね。

11章を一通り最後まで読み終わった。
selfのシンタックスシュガーなだけ、とか、全部extention methodっぽいとか、いろいろ気に入った。

rust、ちょっと好きになってきたよ。

### 12章 Operator Overloadingは読み飛ばす

さすがにかったるいので適当に読み飛ばす。
ちらちら見た感じ、別段面白い事も無いので。

indexerのmutのあたりは良く分からない部分もあったが、この辺はどうせ実際に書いてみないと良く分からないだろうからあまり気にしない。

### 13章 Utility Traits

Sizedの所が良く分からない。

trait objectがsizedじゃない、という事は、オブジェクトがmoveされてくる、という事なのかね。ポインタじゃなくて。

そしてRcBoxのDisplayの意味が分からなくて少し考える。
ああ、最初Stringだったのが、DisplayのTrait objectに変換されるのか。

へー、つまり構造体のサイズが変わってるのね。
まじかよ。

deref coercionはいろいろハマりそうだなぁ。このgenericsの例とかうんざりだ…

Intoもシグニチャがなかなか難解になるね。
このごちゃごちゃしたシグニチャのおかげでコンパイラの型チェックの力を引き出す、という話だよなぁ。

Cowの所はちゃんと理解出来た感じでも無いが、だいたいイメージは分かるからいいか。

## 14章 Closure

closureは型が全て違う、という話を見て、へー、っと思う。

型が分かるとコードの場所が分かる、
とあるから、呼ぶ時はcall文になるのかね。genericsだからinlining出来るのはなるほど。

generics以外で共通の変数に入れたい場合はどうするんだろ？Boxとかに入れると関数ポインタとenv相当の構造体を入れるのかな。Callbacksというセクションで扱うらしいので楽しみにしておく。

C++のlambdaと同じくらい早い、と書いてあるが、C++もこんな作りなのかな？実際の実装とかメモリレイアウトとか全然知らんな、そういえば。

FnOnceの仕組み、面白いね。Selfのmoveで表現される、とかなかなかおしゃれだ。

これのおかげで型チェックがミスを教えてくれる、というのはなかなかいい話だな。

Callbacksを読んだ。やはりBoxに入れるらしい。何が起こるか詳しくは書いてないが、関数ポインタが入るのだろう。  

14章読み終わった。RustのClosure、良さそうね。
コンパイラのコードも読んでみたいな。

### 15章 iterator

iterとiter_intoの2つがある理由がいまいち分からなかった。
sharedなiterを使うのにシンタックス的にかったるいからか？

collect(・∀・)ｲｲﾈ!!

やっぱりlistでくくるよりは最後に書きたいよなぁ。

なんかアンパサンドはややこしいね。
実際にこういうので悩むのはもう嫌だなぁ。

最初はバグ無く安心して書けるならちょろっとした用途でもいいかな、と思ってたが、ちょろっとした用途でこういうの考えるの嫌だね。

floatのmaxが無いのとか、
max_by_keyにclsure渡してwhich.max的なの出したり、この辺はイマイチかっこよくないね。

なんかこんなgenericsばっかだとコンパイル時間が長いんじゃない？と思って[ググってみると](https://users.rust-lang.org/t/are-there-any-compilation-time-benchmarks-of-rust-vs-g-vs-clang/4895)、遅そう…
でも[そこからのリンク先](https://ruudvanasseldonk.com/2014/10/20/writing-a-path-tracer-in-rust-part-7-conclusion)は早そう。

`-Z no-trans`つけると早くなるっぽい。これが何かは知らんけど、開発時のイテレーションが短いなら良さそう。

この辺は触ってみないと分からんところね。

お、ツリーのiterator作るのにスタックが要るとか言ってる。システムプログラムレベル低いな。

とりあえず15章読み終わったので感想とか。

この章はPythonでデータ分析してる身としては割と普段使ってるような奴ばかりだ。  
ただ、そのせいで、アンパサンドが2つつく、とか説明見ると相当うんざりするものがある。

やはり大規模な物か組み込みだよなぁ。
あんまり日常のちょろっとした事書きたい、とは思わない。

ただC++の代わりならいいか、という気もする。

### 飛行機の中で16章、17章を読む

那覇からのもどりの飛行機で読んでたら、メモを取らずにサクサク進んだ。
Collectionとテキストのformatなんでだいたい読み飛ばしてるから、というのはあるが。

あとはマクロとconcurrent以外は大して面白くも無さそうなので、とっとと読み飛ばして行きたい。

rustはメモリ食わずに速そうだけど、この2つが必要なシーンのアプリってあんまり最近はサーバーサイドでは書かないよなぁ、という気もした。
MapReduceとか書くならgolangよりこっちの方がいいかも？くらい。
ただそんなスクリプトの実行時間が問題にはならないんだよなぁ。

Androidのアプリとかでは良くあるのだが、JNIで使えても速く無いしねぇ、Androidの場合。

やっぱりDOS Extenderとかでやってるドライバとかを置き換える、とかが良い気がした。

### 18章のInputとOutputは読み飛ばし

さらさら眺めたが別段読む所無く最後まで行ってしまった。
OsStrとかPath周りがちゃんとしているのは好感が持てるね。
この辺いい加減な言語でシステムプログラミングする気は起こらないので。

### 19章、concurrent

これは半分くらいはまじめに読む。
他のプログラミング言語と同じような部分は読み飛ばすが。

確かにmutとかmoveは並列に良さそう。
ただこういうコードはそもそも書きたくないなぁ、とか思ってしまうが。
MapReduceとかRabbitMQとかRxとかTensorflowとか、昨今はいろいろ制約した形の並列はあるからねぇ。

### 20章、マクロ

rustのマクロは自分の知る中でもっとも良く出来ている気がする。
hygieneticで、しかも言語の構文要素にアクセス出来るので、落とし穴的な展開も少ない。
デバッグもリーズナブルな程度にはしやすい。

が、もうこういうのは使いたくないなぁ、というのが正直な感想。
最近はマクロよりもkotlinのbuilderとかC#のLINQみたいなのがいいなぁ。
昔はこういうの凄いと思ってたが、
こうしてみるとプログラム言語もいろいろ進歩してるやね。

### 21章 Unsafe

rustを使う予定が無いのでそんな細かい事読んでもなぁ、という気もするけれど、一応他の言語とはいろいろ違いそうな所なので読んでおく。

intからraw pointerへの変換は、
基本的には元がポインタから来た物くらいなもんだ、とか書いてあってビビる。システムプログラミング的にはメモリマップドな物を触りたいケースの方がよっぽど多いと思うのだが…  
まぁ分かる人が読めば分かるんで別に良いのだけれど。

もう忘れかかってたので、一気に最後まで読んでしまう事にする。libgit2のsafeなAPIラッパを作るあたりは大分飛ばし読みだったが。

ffiは微妙だなぁ、と思うけど、ちゃんと決められているのは良いね。
微妙な物から逃げない姿勢は評価出来る。

という事で読み終わったので感想。

### 本の感想

自分はrustを使う予定は無くて、どんな言語か知りたい、という好奇心で読んだ。
そういう点で自分は本来の想定読者では無いかもしれない。
それを踏まえて以下は読んでください。

最初のマンデルブロの例とかは言語よりもアルゴリズムとかの説明の方が長く、開幕どんな言語かワクワク読み始める読者の心を砕きに来てて、そりゃ無いよ、と思った。

また、最初の方につまらない物が集まっててconcurrentが19章、macroは20章と最後の方に固まってるのも、言語としての特徴に興味を持ってる自分としては嫌な並び方だった。
読んでて面白い、と感じるように書こうという意識は低い気がした。

ただ並び方とか例の選び方は微妙な気もしたけど、内容は良かった。
著者はメモリレイアウトとかも良く理解していて、C++やCプログラマがどの辺を疑問に思うのかは良く分かって書いている。
イマドキのスクリプト言語や関数型言語を知ってる人からすると冗長な所はあるが、読み飛ばせば良いだろう。

読んでいて「この辺の事が実際どうなってるのかもっと知りたいなぁ」と思った場所は一箇所も無かった。
知りたい事を知りたいレベル以上にはちゃんと解説されていて、好感が持てた。

あと章の構成はしっかりしてるので、あとから見直すのはやりやすい。たぶんrustを使う人にとっては読み終わったあともリファレンス的に使える良い本だと思う。

全体的には、退屈な所はあるが期待には応えた。

### 言語としてのrust雑感

C++の代わりに使いたいな、と思うが、C++を使うような事自体なるべくしたくない、と思うので、使い所が思いつかない。

ちょろっとした事を書くには最初見た印象よりは意外と面倒そうで向いて無さそうだな、と思った。特にアンドをたくさんつけたりするのは嫌だ。

関数型言語の良い所はかなり取り入れているなぁ、と思う。
予備知識あまり無く読んだので、思ったよりも関数型言語っぽくて驚いた。
代数的データ型とか。

また構造体とtraitsって構成は普通のclassよりも気に入った。
もともと既存のclassシステムはextention method と相性が悪いというか、美しく統合されてないなぁ、と思っていたので、こちらの方が良い気がした。

mutとかmoveとかborrowとかやlife timeのパラメータがあるのは面白いね。
噂には聞いていたが、なるほど、という感じだった。これはprimitiveな並列プログラム書くには良さそう。
だがもうあんまそういの書きたくないな、という思いも強い。

exception無いのも面白いね。
いまどき珍しい。
これは小さい所で使う気になる。

マクロは言語の構文要素に触れるのはいいね。
exprとかの単位で書く方がいい事多いよな。
変数捕捉にもちゃんと対応してるし完璧なマクロシステムと思う。
ただもうマクロとか使いたくないなぁ、と思う自分を発見し、自分の老いを感じるなどした…

どうせならもっと組み込み用途なら良かったのになぁ、と思う。UTF8要らないのでもっとランタイム小さくして欲しい。
リアルモードで動かしたりメモリマップトIO叩いたり、そういうのメインな言語なら個人的に使いみちも思いつくのになぁ。

rustどうこう、という訳では無いのだが、最近の言語はどれも似通ってるよなぁ。
自分が普段書いてる言語だとkotlinとシンタックスが似てるので、本読んだあとにAndroidアプリ書くと凄い混ざる。

それはある種の結論という事なのだろうけれど、趣味で学ぶには少し刺激がなくて物足りない。
swiftやったあとだからかもしれないけど、なんかまた似たような事学んでるなぁ…と思ってしまった。

結論、使いみちは思いつかない。つかってる所でちょっと働いてみたい気はする。
向いてるシチュエーションなら使ってみたいと思うくらいには良い言語だが、向いてるシチュエーションに近づきたいとはあまり思えなかった。
教養として勉強してみるのには悪くなかったが、もうちょっと飛ばし読みしても良かったかも。
