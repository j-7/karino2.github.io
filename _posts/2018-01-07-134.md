---
title: "確率的プログラミングその2、probmods"
date: 2018-01-07 01:52:43
---

dipplのサイトを一通り見たが[良く分からなかった](https://karino2.github.io/2018/01/04/132.html)ので、WepPPL自体の入門文書が無いもんかなぁ、と本家を見たら、以下のサイトを紹介してた。

[https://probmods.org/](https://probmods.org/)

という事で軽く読んでみよう。


### Inferが出てきた

Inferは何なのか、というのがちょっと分かってくる例だな。
Inferしないと分布は分からない訳か。なるほど。

sampleとInferの違いを十分正確に分かってる訳では無いが、おいおい分かっていく事を期待して進む。

### 確率の話がだるい

Product rule とかの話はさすがにかったるい。
確率的プログラミングの入門文書の難しさはここだよな。
読者に想定してよい範囲が全然わからない。でも全部最初から説明しようとすると膨大になってしまって読めたもんじゃない。

ちゃんと主流になれば、プログラマが読むべき定番確率本とかが出来て、それを参照して終わるのだろうけれどねぇ。

### Stochastic recursion

再帰を特別にこう書いているのは、やはりまずは限られたprimitiveだけサポートされている、という風に話をする方が良いからだよなぁ。
やっぱりこうやって順番にやっていく方が分かりやすくて良いね。

ただかったるい。
最初にこれをやってると単なる関数呼び出しとかにしか見えないので、かえって分からなくなる、という側面はありそう。

### Persistent Randomness

さて、分かりやすい入門の体でここまで来てしまったので、この文書だけでここまで来ると、ここでなんで単にフィールドに保存しとくだけじゃ駄目なの？というのがわからなさそう。

ただ、dipplのサイトを見た後なので、この辺のprimitiveが必要なのは分かる。

このあとのExerciseをちらっと見たが、これはほとんど確率のテストであって、知りたいのはここじゃないんだよなぁ、と思った。
ので、先に進む。

## Conditioning

conditionの所まで来る。Conditional Distributionsとかの確率の話はまぁさすがに要らないので読み飛ばす。

このページの7割くらいは確率の話なので要らない。
なかなか手頃な入門は難しいねぇ。

今の所enumerateとrejectionの差が分からない。
enumerateって何するの？

### observe

最初の例が何故終わらないのか？少し考える。

それはobsXが0.2になるまでサンプリングを続けるが、これってほとんど当たらないから。連続分布だからね。なるほど。

### var Dを置くと何が違う？

そのあとvar Dを置くかそのままcondの中に式書くかは全然違う、と書かれてる。
何が違うか全然分からん…

しばらく考えてみたがやはり分からない。
まったく同じにしか感じられないのだが、何が違うのだろう。

observeとconditionの違いを言っているのかな。
conditionはbooleanな条件を記述している。
一方observeはそういう確率変数が観測された、という事を表している。
事象と確率変数の違いか？

まぁいいや、良く分からんけど先に進もう。

### directedとundirected

sampleとobserveだけなgenerative modelをdirected、factorがあるとundirectedと言う、と書いてある。

directedとundirectedというとBNとMRFの事っぽい気もするけれど、どうだろう？ちょっと考えてみよう。

factorはMRFのfactor、つまりpotentialと同じだろうか？
向こうのは、それの積をとるとunnormalizeな同時確率になる、という性質が根本にあった。
このfactorはどうだろう？

引数の実数を受け取り、その時の実行が実現するlog確率に足す訳だ。

その時の実行が実現するlog確率、というのは、MRFの意味でのfactorの引数は何になるのだろうか？
それはその実数値を求めるのに使った確率変数になる訳だよな。

お、なるほど。MRFのfactorになってるな。
つまりこのdirectedとundirectedはBNとMRFの事で、conditionとsample だとBN、factorが入るとMRF と考えられるのだな。

ただネットワークは明示的には定義されないので結構微妙だが。

### Tug warのExampleが良い

ここまで来ると、どういう感じでプログラムするのかは大分分かってくるな。
実際にどう動くのかの詳細は良く分からないが。


その後の診断のコードもサンプルとして良いね。
ただCognitionには大して関心無いのでその辺の話は無い方が嬉しいが。

### Patterns of inferenceの手前まで読んで分からない事

Pattern of interestsから先は通常のベイジアンネットワークの話で確率的プログラミングの話はあまり無さそうなので、ここまででこの文書は読み終わりでいいかなぁ。

大分どういう物か理解は深まったが、分からない事が幾つかある。

1. 分布に対して許されている演算は何か？
2. sampleとは何か？

まず分布に対して全てが許されているのかが良く分からない。
関数の中で触る事は許されていて、その関数が再帰するのが許されているのも分かるが。

例えばif文は許されているのか？とかが良く分からない。
三項演算子とかは許されてそうだけど。

次に分からないのがsample関数。
ぱっと見は何かしらのdeterministicな値を返しそうなんだけど、あってる？いまいちその辺が良く分からない。

他はだいたいどうやってプログラミングするかは理解出来た気がする。
書いたプログラムがどう動くかはまだ良く分かってないが。
